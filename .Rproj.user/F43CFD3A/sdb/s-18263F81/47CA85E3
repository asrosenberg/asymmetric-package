{
    "collab_server" : "",
    "contents" : "boundary_routine <- function(dat, input = input, output = output, method)\n{\n  dat$x <- input\n  dat$y <- output\n  id <- order(dat$x)\n  divide_by_this <- (max(dat$x) - min(dat$x)) * (max(dat$y) - min(dat$y))\n  ymin <- min(dat$y)\n  idx <- sample(1:nrow(dat), nrow(dat), replace=TRUE)\n  sample.dta <- dat[idx,]\n  y <- sample.dta$y\n  x <- sample.dta$x\n  if(method == \"Polynomial\")\n  {\n    odeg <- opt_degree(x, y, x, prange=0:20)\n    polfront <- poly_estimate(x, y, x, deg = odeg)\n    AUC_poly <- sum(diff(sort(x)) * rollmean(sort(polfront), 2))\n    AUC_lower <- sum(diff(dat$x[id]) * ymin)\n    AUC_difference <- AUC_poly - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    result <- 1 - AUC_percent\n  }\n  if(method == \"Kernel\")\n  {\n    bw <- kern_smooth_bw(x, y)\n    kernsmooth <- kernel_smoothing(x, y, x, h = bw)\n    AUC_kern <- sum(diff(sort(x)) * rollmean(sort(kernsmooth), 2))\n    AUC_lower <- sum(diff(dat$x[id]) * ymin)\n    AUC_difference <- AUC_kern - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    result <- 1 - AUC_percent\n  }\n  if(method == \"SFA\")\n  {\n    ka_sfa <- sfa(y ~ x | x, ineffDecrease = TRUE, data = sample.dta)\n    y_sfa <- ka_sfa$mleParam[1] + ka_sfa$mleParam[2] * x\n    AUC_sfa <- sum(diff(sort(dat$x)) * rollmean(sort(y_sfa), 2))\n    AUC_lower <- sum(diff(dat$x[id]) * ymin)\n    AUC_difference <- AUC_sfa - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    result <- 1 - AUC_percent\n  }\n  if(method == \"QR\")\n  {\n    ka_qr <- rq(output ~ input, tau = 0.95, data = sample.dta)\n    y_qr <- ka_qr$coefficients[1] + ka_qr$coefficients[2] * input\n    AUC_qr <- sum(diff(sort(input)) * rollmean(sort(y_qr), 2))\n    AUC_lower <- sum(diff(input[id]) * ymin)\n    AUC_difference <- AUC_qr - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    result <- 1 - AUC_percent\n  }\n  result\n}\n\nAH_AOC <- function(dat, input, output, method, print_style = \"ascii\",\n  CI = FALSE, nboots)\n{\n  AOC_estimates <- lapply(method, which_technique_to_use, dat = dat,\n    input = input, output = output)\n  estimates <- round(do.call(rbind, AOC_estimates), digits = 3)\n  rownames(estimates) <- method\n  colnames(estimates) <- \"AOC\"\n\n  if(CI == TRUE)\n  {\n    samples <- lapply(method, replicates, nboots = nboots, dat = dat,\n      input = input, output = output)\n    CIs <- lapply(samples, quantile, probs = c(0.025, 0.5, 0.975))\n    CIs <- round(do.call(rbind, CIs), digits = 3)\n    CI_estimates <- cbind(estimates, CIs)\n    CI_estimates <- cbind(method, CI_estimates)\n    estimates_df <- as.data.frame(CI_estimates)\n  }\n  if(CI == FALSE)\n  {\n    add_rows_names <- cbind(method, estimates)\n    estimates_df <- as.data.frame(add_rows_names)\n  }\n  if(print_style == \"ascii\")\n  {\n    asciify(estimates_df)\n  }\n  if(print_style == \"R\")\n  {\n    return(estimates_df)\n  }\n}\n\nwhich_technique_to_use <- function(method, dat, input = input, output = output)\n{\n  id <- order(input)\n  divide_by_this <- (max(input) - min(input)) * (max(output) - min(output))\n  ymin <- min(dat$y)\n  if(method == \"QR\"){\n    ka_qr <- rq(output ~ input, tau = 0.95, data = dat)\n    y_qr <- ka_qr$coefficients[1] + ka_qr$coefficients[2] * input\n    AUC_qr <- sum(diff(input[id]) * rollmean(sort(y_qr), 2))\n    AUC_lower <- sum(diff(input[id]) * ymin)\n    AUC_difference <- AUC_qr - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    qr_result <- 1 - AUC_percent\n    return(qr_result)\n  }\n  if(method == \"SFA\"){\n    ka_sfa <- sfa(output ~ input | input, ineffDecrease = TRUE, data = dat)\n    y_sfa <- ka_sfa$mleParam[1] + ka_sfa$mleParam[2] * input\n    AUC_sfa <- sum(diff(input[id]) * rollmean(sort(y_sfa), 2))\n    AUC_lower <- sum(diff(input[id]) * ymin)\n    AUC_difference <- AUC_sfa - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    sfa_result <- 1 - AUC_percent\n    return(sfa_result)\n  }\n\n  if(method == \"Polynomial\"){\n    odeg <- opt_degree(xtab = input, ytab = output, x = input, prange = 1:20)\n    polfront <- poly_estimate(input, output, x = input, deg = odeg)\n    AUC_poly <- sum(diff(input[id]) * rollmean(sort(polfront), 2))\n    AUC_lower <- sum(diff(input[id]) * ymin)\n    AUC_difference <- AUC_poly - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    poly_result <- 1 - AUC_percent\n    return(poly_result)\n  }\n\n  if(method == \"Kernel\"){\n    bw <- kern_smooth_bw(input, output, method = \"u\", technique = \"noh\",\n      bw_method=\"bic\")\n    kernsmooth <- kernel_smoothing(input, output, input, h = bw)\n    AUC_kern <- sum(diff(input[id]) * rollmean(sort(kernsmooth), 2))\n    AUC_lower <- sum(diff(input[id]) * ymin)\n    AUC_difference <- AUC_kern - AUC_lower\n    AUC_percent <- AUC_difference/divide_by_this\n    kern_result <- 1 - AUC_percent\n    return(kern_result)\n  }\n}\n\nreplicates <- function(method, nboots, dat, input, output)\n{\n  samples <- replicate(nboots, boundary_routine(dat, method = method,\n    input = input, output = output))\n}\n\n\n\nasciify <- function(df, pad = 1, ...) {\n  ## error checking\n  stopifnot(is.data.frame(df))\n  ## internal functions\n  SepLine <- function(n, pad = 1) {\n    tmp <- lapply(n, function(x, pad) paste(rep(\"-\", x + (2* pad)),\n                                            collapse = \"\"),\n                  pad = pad)\n    paste0(\"+\", paste(tmp, collapse = \"+\"), \"+\")\n  }\n  Row <- function(x, n, pad = 1) {\n    foo <- function(i, x, n) {\n      fmt <- paste0(\"%\", n[i], \"s\")\n      sprintf(fmt, as.character(x[i]))\n    }\n    rowc <- sapply(seq_along(x), foo, x = x, n = n)\n    paste0(\"|\", paste(paste0(rep(\" \", pad), rowc, rep(\" \", pad)),\n                      collapse = \"|\"),\n           \"|\")\n  }\n  ## convert everything to characters\n  df <- as.matrix(df)\n  ## nchar in data\n  mdf <- apply(df, 2, function(x) max(nchar(x)))\n  ## nchar in names\n  cnames <- nchar(colnames(df))\n  ## max nchar of name+data per elements\n  M <- pmax(mdf, cnames)\n  ## write the header\n  sep <- SepLine(M, pad = pad)\n  writeLines(sep)\n  writeLines(Row(colnames(df), M, pad = pad))\n  writeLines(sep)\n  ## write the rows\n  for(i in seq_len(nrow(df))) {\n    ## write a row\n    writeLines(Row(df[i,], M, pad = pad))\n    ## write separator\n    writeLines(sep)\n  }\n  invisible(df)\n}\n\n\ndesMthing <- function(i, xtab = xtab)\n{\n  xtab^i\n}\n\ngridMthing <- function(i, x = x, xtab = xtab)\n{\n  x^i\n}\npoly_estimate <- function(xtab, ytab, x, deg)\n{\n  opt_coef <- (1/(1:(deg + 1))) * (max(xtab)^(1:(deg + 1)) -\n    min(xtab)^(1:(deg + 1)))\n  desM <- sapply(0:deg, desMthing, xtab = xtab)\n  dir <- c(rep(\">=\", length(xtab)))\n  bounds <- list(lower = list(ind = 1:(deg + 1), val = rep(-Inf,\n    deg + 1)), upper = list(ind = 1:(deg + 1), val = rep(Inf, deg + 1)))\n  Sol <- Rglpk_solve_LP(obj = opt_coef, mat = desM,\n    dir = c(rep(\">=\", length(xtab))), rhs = ytab,\n    bounds, types = NULL, max = FALSE)\n  OPT <- Sol$solution\n  gridM <- sapply(0:deg, gridMthing, xtab = xtab, x = x)\n  fitt <- gridM %*% OPT\n  return(fitt)\n}\n\ndifs <- function(i, xs, ys, x = x)\n{\n  log(sum(abs(ys - poly_estimate(xtab = xs,\n    ytab = ys, x = x, i)))) + (i + 1)/length(xs)\n}\n\nopt_degree <- function(xtab, ytab, x, prange = 0:20)\n{\n  criteria <- cbind(prange, sapply(prange, difs, xs = xtab, ys = ytab, x = x))\n  return(prange[which.min(criteria[, 2])])\n}\n\nbootstrap_degrees <- function(dta)\n{\n  opt_degree(xtab = dta$gdp, ytab = dta$life)\n}\n\nbs.sample <- function(dta, ...)\n{\n  idx <- sample(1:nrow(dta), nrow(dta), replace=TRUE)\n  dta <- dta[idx,]\n  rownames(dta) <- NULL\n  dta\n}\n\nbootstrap_estimates <- function(i)\n{\n  dta <- bootstrapped_data[[i]]\n  deg <- degrees[[i]]\n  poly_estimate(dta[, gdp], dta[, life], x = mydat$gdp, deg = deg)\n}\n\nbs.routine <- function(dta)\n{\n  idx <- sample(1:nrow(dta), nrow(dta), replace=TRUE)\n  sample.dta <- dta[idx,]\n  y <- sample.dta$y\n  x <- sample.dta$x\n  odeg <- opt_degree(x, y, analysis_dat$x, prange=0:20)\n  polfront <- poly_estimate(x, y, analysis_dat$x, deg = odeg)\n  #ys <- 1 - polfront\n  #xs <- 1 - x\n  #list(cbind(xs, ys))\n  #list(cbind(1 - x, 1 - polfront))\n  c(1 - polfront)\n}\n\nbs.routine.beta <- function(dta)\n{\n  idx <- sample(1:nrow(dta), nrow(dta), replace=TRUE)\n  sample.dta <- dta[idx,]\n  y <- sample.dta$y\n  x <- sample.dta$x\n  bw <- kern_smooth_bw(x, y, method=\"u\", technique=\"noh\", bw_method=\"bic\")\n  kernsmooth <- kernel_smoothing(x, y, analysis_dat$x, h = bw)\n  c(1 - kernsmooth)\n}\n\nbs.routine_general <- function(xtab, dta, method)\n{\n  idx <- sample(1:nrow(dta), nrow(dta), replace=TRUE)\n  sample.dta <- dta[idx,]\n  y <- sample.dta$y\n  x <- sample.dta$x\n  if(method == \"Kernel\")\n  {\n    bw <- kern_smooth_bw(x, y, method=\"u\", technique=\"noh\", bw_method=\"bic\")\n    kernsmooth <- kernel_smoothing(x, y, x, h = bw)\n    return(kernsmooth)\n  }\n  if(method == \"Poly\")\n  {\n    odeg <- opt_degree(x, y, xtab, prange=0:20)\n    polfront <- poly_estimate(x, y, xtab, deg = odeg)\n    return(polfront)\n  }\n  if(method == \"QR\")\n  {\n    qr <- rq(y ~ x, tau = 0.95, data = sample.dta)\n    return(qr$fitted.values)\n  }\n}\n\ncomb_dat <- function(dat, ...)\n{\n  dat[, gdp]\n}\n\nput_wealth_health_together <- function(i)\n{\n  cbind(wealth[[i]], hw_bs_est[[i]])\n}\n\nkern_smooth_bw<-function(xtab, ytab, method=\"u\", technique=\"noh\", bw_method=\"bic\")\n{\n  n<-length(xtab)\n  ndata<-length(xtab) # number of data points\n\n  # sorting step to use the Priestly-Chao estimator\n  oind<-order(xtab)\n  xtab<-xtab[oind]\n  ytab<-ytab[oind]\n\n  if (technique==\"noh\" && bw_method==\"bic\")\n  {\n    h_min<-2*max(diff(sort(xtab)))\n    h_max<-(max(xtab)-min(xtab))\n    h_grid<-seq(h_min,h_max,length=184)\n\n    BIC<-NULL\n\n    for ( h in h_grid)\n    {\n      Phi<-kernel_smoothing(xtab,ytab,xtab,h,method,technique=\"noh\")\n\n      # calculating model complexity\n      xtab2<-xtab[-1]\n      ytab2<-ytab[-1]\n      DX<-diff(xtab)\n\n      A<-dnorm(outer(xtab,xtab2,'-')/h)/h\n      B<-rep(1,n) %*% t(ytab2*DX)\n      S<-A * rep(1,n) %*% t(DX)\n      SS<-S[-1,]\n      DF<-sum(diag(SS))\n\n      BIC<-c(BIC,log(sum(abs(ytab-Phi)))+log(length(ytab))*DF/(2*length(ytab)))\n    }\n\n    if (which.min(BIC)==1) {mind<-which.min(BIC[-1])+1}\n    if (which.min(BIC)>1) {mind<-which.min(BIC)}\n    hopt<- h_grid[mind]\n  }\n\n  if (technique==\"noh\" && bw_method==\"cv\")\n  {\n    bw<-npregbw(xdat=xtab, ydat=ytab, regtype=\"lc\", ckertype=\"gaussian\")\n    hopt<-max(max(diff(sort(xtab))),bw$bw)\n  }\n\n\n  if (technique==\"pr\" && bw_method==\"bic\")\n  {\n    h_min<-2*max(diff(sort(xtab)))\n    h_max<-(max(xtab)-min(xtab))\n    h_grid<-seq(h_min,h_max,length=30)\n\n    BIC<-NULL\n\n    for ( h in h_grid)\n    {\n      Phi<-kernel_smoothing(xtab,ytab,xtab,h,method,technique=\"pr\")\n\n      # calculating model complexity\n      xtab2<-xtab[-1]\n      ytab2<-ytab[-1]\n      DX<-diff(xtab)\n\n      A<-dnorm(outer(xtab,xtab2,'-')/h)/h\n      B<-rep(1,n) %*% t(ytab2*DX)\n      S<-A * rep(1,n) %*% t(DX)\n      SS<-S[-1,]\n      DF<-sum(diag(SS))\n\n      BIC<-c(BIC,log(sum(abs(ytab-Phi)))+log(length(ytab))*DF/(2*length(ytab)))\n    }\n    if (which.min(BIC)==1) {mind<-which.min(BIC[-1])+1}\n    if (which.min(BIC)>1) {mind<-which.min(BIC)}\n    hopt<- h_grid[mind]\n\n  }\n\n  if (technique==\"pr\" && bw_method==\"cv\")\n  {\n    bw<-npregbw(xdat=xtab, ydat=ytab, regtype=\"lc\", ckertype=\"gaussian\")\n    hopt<-max(max(diff(sort(xtab))),bw$bw)\n\n  }\n  return(hopt)\n\n}\n\nkernel_smoothing <- function (xtab, ytab, x, h, method = \"u\", technique = \"noh\")\n{\n  stopifnot(method %in% c(\"u\", \"m\", \"mc\"))\n  stopifnot(technique %in% c(\"pr\", \"noh\"))\n  consX <- unique(sort(c(xtab, seq(min(xtab), max(xtab), length = 201))))\n  Cstable = 10000\n  n <- length(xtab)\n  ndata <- length(xtab)\n  ncons <- length(consX)\n  oind <- order(xtab)\n  xtab <- xtab[oind]\n  ytab <- ytab[oind]\n  if (technique == \"noh\") {\n    oind <- order(xtab)\n    xtab <- xtab[oind]\n    ytab <- ytab[oind]\n    xtab2 <- xtab[-1]\n    ytab2 <- ytab[-1]\n    DX <- diff(xtab)\n    r_end <- max(xtab)\n    l_end <- min(xtab)\n    opt_coef <- (pnorm((r_end - xtab2)/h) - pnorm((l_end -\n      xtab2)/h)) * DX * ytab2\n    C0 <- .fitMat(xtab, ytab, xtab, h, type = 0)\n    C1 <- .fitMat(xtab, ytab, consX, h, type = 1)\n    C2 <- .fitMat(xtab, ytab, consX, h, type = 2)\n    obj <- c(opt_coef, -opt_coef)\n    if (method == \"u\") {\n      mat_temp <- C0\n      mat <- rbind(cbind(mat_temp, -mat_temp), rep(1, length(obj)))\n      rhs <- c(ytab, Cstable)\n      dir <- c(rep(\">=\", ndata), \"<=\")\n    }\n    if (method == \"m\") {\n      mat_temp <- rbind(C0, C1)\n      mat <- rbind(cbind(mat_temp, -mat_temp), rep(1, length(obj)))\n      rhs <- c(ytab, rep(0, ncons), Cstable)\n      dir <- c(rep(\">=\", ndata + ncons), \"<=\")\n    }\n    if (method == \"mc\") {\n      mat_temp <- rbind(C0, C1, C2)\n      mat <- rbind(cbind(mat_temp, -mat_temp), rep(1, length(obj)))\n      rhs <- c(ytab, rep(0, 2 * ncons), Cstable)\n      dir <- c(rep(\">=\", ndata + ncons), rep(\"<=\", ncons),\n        \"<=\")\n    }\n    Sol <- Rglpk_solve_LP(obj, mat, dir, rhs, types = NULL,\n        max = FALSE)\n    OPT_temp <- Sol$solution\n    OPT <- OPT_temp[1:length(opt_coef)] - OPT_temp[(length(opt_coef) +\n        1):(length(opt_coef) * 2)]\n    fitt <- .fitMat(xtab, ytab, x, h, 0) %*% OPT\n  }\n  if (technique == \"pr\") {\n    A <- .fitMat_nw(xtab, ytab, xtab, h, type = 0)\n    A.deriv.1 <- .fitMat_nw(xtab, ytab, consX, h, type = 1)\n    A.deriv.2 <- .fitMat_nw(xtab, ytab, consX, h, type = 2)\n    if (method == \"u\") {\n      p.hat <- solve.QP(Dmat = diag(n), dvec = rep(1, n),\n        Amat = t(A), bvec = ytab, meq = 0)$solution\n    }\n    if (method == \"m\") {\n      p.hat <- solve.QP(Dmat = diag(n), dvec = rep(1, n),\n        Amat = cbind(t(A), t(A.deriv.1)), bvec = c(ytab,\n        rep(0, ncons)), meq = 0)$solution\n    }\n    if (method == \"mc\") {\n      p.hat <- solve.QP(Dmat = diag(n), dvec = rep(1, n),\n        Amat = cbind(t(A), t(A.deriv.1), -t(A.deriv.2)),\n        bvec = c(ytab, rep(0, ncons), rep(0, ncons)),\n        meq = 0)$solution\n    }\n    fitt <- .fitMat_nw(xtab, ytab, x, h, type = 0) %*% p.hat\n  }\n  return(as.vector(fitt))\n}\n\nsolve.QP <- function (Dmat, dvec, Amat, bvec, meq = 0, factorized = FALSE)\n{\n  n <- nrow(Dmat)\n  q <- ncol(Amat)\n  if (missing(bvec))\n    bvec <- rep(0, q)\n  if (n != ncol(Dmat))\n    stop(\"Dmat is not symmetric!\")\n  if (n != length(dvec))\n    stop(\"Dmat and dvec are incompatible!\")\n  if (n != nrow(Amat))\n    stop(\"Amat and dvec are incompatible!\")\n  if (q != length(bvec))\n    stop(\"Amat and bvec are incompatible!\")\n  if ((meq > q) || (meq < 0))\n    stop(\"Value of meq is invalid!\")\n  iact <- rep(0, q)\n  nact <- 0\n  r <- min(n, q)\n  sol <- rep(0, n)\n  lagr <- rep(0, q)\n  crval <- 0\n  work <- rep(0, 2 * n + r * (r + 5)/2 + 2 * q + 1)\n  iter <- rep(0, 2)\n  res1 <- .Fortran(.QP_qpgen2, as.double(Dmat), dvec = as.double(dvec),\n    as.integer(n), as.integer(n), sol = as.double(sol), lagr = as.double(lagr),\n    crval = as.double(crval), as.double(Amat), as.double(bvec),\n    as.integer(n), as.integer(q), as.integer(meq), iact = as.integer(iact),\n    nact = as.integer(nact), iter = as.integer(iter), work = as.double(work),\n    ierr = as.integer(factorized))\n  if (res1$ierr == 1)\n    stop(\"constraints are inconsistent, no solution!\")\n  else if (res1$ierr == 2)\n    stop(\"matrix D in quadratic function is not positive definite!\")\n  list(solution = res1$sol, value = res1$crval, unconstrained.solution = res1$dvec,\n       iterations = res1$iter, Lagrangian = res1$lagr, iact = res1$iact[1:res1$nact])\n}\n\n.fitMat <- function (X, Y, consX, h, type = 0)\n{\n  n <- length(X)\n  stopifnot(sum((order(X) - 1:n)^2) == 0)\n  X2 <- X[-1]\n  Y2 <- Y[-1]\n  DX <- diff(X)\n  A <- dnorm(outer(consX, X2, \"-\")/h)/h\n  B <- rep(1, length(consX)) %*% t(Y2 * DX)\n  if (type == 0) {\n    return(A * B)\n  }\n  if (type == 1) {\n    A2 <- .dderi(outer(consX, X2, \"-\")/h)/h^2\n    return(A2 * B)\n  }\n  if (type == 2) {\n    A3 <- .d2deri(outer(consX, X2, \"-\")/h)/h^3\n    return(A3 * B)\n  }\n}\n\n.dderi <- function (x)\n{\n  return(-x * dnorm(x))\n}\n\n.d2deri <- function (x)\n{\n  return((x^2 - 1) * dnorm(x))\n}\n\n",
    "created" : 1483813608863.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3840124004",
    "id" : "47CA85E3",
    "lastKnownWriteTime" : 1483812427,
    "last_content_update" : 1483812427,
    "path" : "~/asymmetric-package/R/functions.R",
    "project_path" : "R/functions.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}