return(qr$fitted.values)
}
}
comb_dat <- function(dat, ...)
{
dat[, gdp]
}
put_wealth_health_together <- function(i)
{
cbind(wealth[[i]], hw_bs_est[[i]])
}
kern_smooth_bw<-function(xtab, ytab, method="u", technique="noh", bw_method="bic")
{
n<-length(xtab)
ndata<-length(xtab) # number of data points
# sorting step to use the Priestly-Chao estimator
oind<-order(xtab)
xtab<-xtab[oind]
ytab<-ytab[oind]
if (technique=="noh" && bw_method=="bic")
{
h_min<-2*max(diff(sort(xtab)))
h_max<-(max(xtab)-min(xtab))
h_grid<-seq(h_min,h_max,length=184)
BIC<-NULL
for ( h in h_grid)
{
Phi<-kernel_smoothing(xtab,ytab,xtab,h,method,technique="noh")
# calculating model complexity
xtab2<-xtab[-1]
ytab2<-ytab[-1]
DX<-diff(xtab)
A<-dnorm(outer(xtab,xtab2,'-')/h)/h
B<-rep(1,n) %*% t(ytab2*DX)
S<-A * rep(1,n) %*% t(DX)
SS<-S[-1,]
DF<-sum(diag(SS))
BIC<-c(BIC,log(sum(abs(ytab-Phi)))+log(length(ytab))*DF/(2*length(ytab)))
}
if (which.min(BIC)==1) {mind<-which.min(BIC[-1])+1}
if (which.min(BIC)>1) {mind<-which.min(BIC)}
hopt<- h_grid[mind]
}
if (technique=="noh" && bw_method=="cv")
{
bw<-npregbw(xdat=xtab, ydat=ytab, regtype="lc", ckertype="gaussian")
hopt<-max(max(diff(sort(xtab))),bw$bw)
}
if (technique=="pr" && bw_method=="bic")
{
h_min<-2*max(diff(sort(xtab)))
h_max<-(max(xtab)-min(xtab))
h_grid<-seq(h_min,h_max,length=30)
BIC<-NULL
for ( h in h_grid)
{
Phi<-kernel_smoothing(xtab,ytab,xtab,h,method,technique="pr")
# calculating model complexity
xtab2<-xtab[-1]
ytab2<-ytab[-1]
DX<-diff(xtab)
A<-dnorm(outer(xtab,xtab2,'-')/h)/h
B<-rep(1,n) %*% t(ytab2*DX)
S<-A * rep(1,n) %*% t(DX)
SS<-S[-1,]
DF<-sum(diag(SS))
BIC<-c(BIC,log(sum(abs(ytab-Phi)))+log(length(ytab))*DF/(2*length(ytab)))
}
if (which.min(BIC)==1) {mind<-which.min(BIC[-1])+1}
if (which.min(BIC)>1) {mind<-which.min(BIC)}
hopt<- h_grid[mind]
}
if (technique=="pr" && bw_method=="cv")
{
bw<-npregbw(xdat=xtab, ydat=ytab, regtype="lc", ckertype="gaussian")
hopt<-max(max(diff(sort(xtab))),bw$bw)
}
return(hopt)
}
kernel_smoothing <- function (xtab, ytab, x, h, method = "u", technique = "noh")
{
stopifnot(method %in% c("u", "m", "mc"))
stopifnot(technique %in% c("pr", "noh"))
consX <- unique(sort(c(xtab, seq(min(xtab), max(xtab), length = 201))))
Cstable = 10000
n <- length(xtab)
ndata <- length(xtab)
ncons <- length(consX)
oind <- order(xtab)
xtab <- xtab[oind]
ytab <- ytab[oind]
if (technique == "noh") {
oind <- order(xtab)
xtab <- xtab[oind]
ytab <- ytab[oind]
xtab2 <- xtab[-1]
ytab2 <- ytab[-1]
DX <- diff(xtab)
r_end <- max(xtab)
l_end <- min(xtab)
opt_coef <- (pnorm((r_end - xtab2)/h) - pnorm((l_end -
xtab2)/h)) * DX * ytab2
C0 <- .fitMat(xtab, ytab, xtab, h, type = 0)
C1 <- .fitMat(xtab, ytab, consX, h, type = 1)
C2 <- .fitMat(xtab, ytab, consX, h, type = 2)
obj <- c(opt_coef, -opt_coef)
if (method == "u") {
mat_temp <- C0
mat <- rbind(cbind(mat_temp, -mat_temp), rep(1, length(obj)))
rhs <- c(ytab, Cstable)
dir <- c(rep(">=", ndata), "<=")
}
if (method == "m") {
mat_temp <- rbind(C0, C1)
mat <- rbind(cbind(mat_temp, -mat_temp), rep(1, length(obj)))
rhs <- c(ytab, rep(0, ncons), Cstable)
dir <- c(rep(">=", ndata + ncons), "<=")
}
if (method == "mc") {
mat_temp <- rbind(C0, C1, C2)
mat <- rbind(cbind(mat_temp, -mat_temp), rep(1, length(obj)))
rhs <- c(ytab, rep(0, 2 * ncons), Cstable)
dir <- c(rep(">=", ndata + ncons), rep("<=", ncons),
"<=")
}
Sol <- Rglpk_solve_LP(obj, mat, dir, rhs, types = NULL,
max = FALSE)
OPT_temp <- Sol$solution
OPT <- OPT_temp[1:length(opt_coef)] - OPT_temp[(length(opt_coef) +
1):(length(opt_coef) * 2)]
fitt <- .fitMat(xtab, ytab, x, h, 0) %*% OPT
}
if (technique == "pr") {
A <- .fitMat_nw(xtab, ytab, xtab, h, type = 0)
A.deriv.1 <- .fitMat_nw(xtab, ytab, consX, h, type = 1)
A.deriv.2 <- .fitMat_nw(xtab, ytab, consX, h, type = 2)
if (method == "u") {
p.hat <- solve.QP(Dmat = diag(n), dvec = rep(1, n),
Amat = t(A), bvec = ytab, meq = 0)$solution
}
if (method == "m") {
p.hat <- solve.QP(Dmat = diag(n), dvec = rep(1, n),
Amat = cbind(t(A), t(A.deriv.1)), bvec = c(ytab,
rep(0, ncons)), meq = 0)$solution
}
if (method == "mc") {
p.hat <- solve.QP(Dmat = diag(n), dvec = rep(1, n),
Amat = cbind(t(A), t(A.deriv.1), -t(A.deriv.2)),
bvec = c(ytab, rep(0, ncons), rep(0, ncons)),
meq = 0)$solution
}
fitt <- .fitMat_nw(xtab, ytab, x, h, type = 0) %*% p.hat
}
return(as.vector(fitt))
}
solve.QP <- function (Dmat, dvec, Amat, bvec, meq = 0, factorized = FALSE)
{
n <- nrow(Dmat)
q <- ncol(Amat)
if (missing(bvec))
bvec <- rep(0, q)
if (n != ncol(Dmat))
stop("Dmat is not symmetric!")
if (n != length(dvec))
stop("Dmat and dvec are incompatible!")
if (n != nrow(Amat))
stop("Amat and dvec are incompatible!")
if (q != length(bvec))
stop("Amat and bvec are incompatible!")
if ((meq > q) || (meq < 0))
stop("Value of meq is invalid!")
iact <- rep(0, q)
nact <- 0
r <- min(n, q)
sol <- rep(0, n)
lagr <- rep(0, q)
crval <- 0
work <- rep(0, 2 * n + r * (r + 5)/2 + 2 * q + 1)
iter <- rep(0, 2)
res1 <- .Fortran(.QP_qpgen2, as.double(Dmat), dvec = as.double(dvec),
as.integer(n), as.integer(n), sol = as.double(sol), lagr = as.double(lagr),
crval = as.double(crval), as.double(Amat), as.double(bvec),
as.integer(n), as.integer(q), as.integer(meq), iact = as.integer(iact),
nact = as.integer(nact), iter = as.integer(iter), work = as.double(work),
ierr = as.integer(factorized))
if (res1$ierr == 1)
stop("constraints are inconsistent, no solution!")
else if (res1$ierr == 2)
stop("matrix D in quadratic function is not positive definite!")
list(solution = res1$sol, value = res1$crval, unconstrained.solution = res1$dvec,
iterations = res1$iter, Lagrangian = res1$lagr, iact = res1$iact[1:res1$nact])
}
.fitMat <- function (X, Y, consX, h, type = 0)
{
n <- length(X)
stopifnot(sum((order(X) - 1:n)^2) == 0)
X2 <- X[-1]
Y2 <- Y[-1]
DX <- diff(X)
A <- dnorm(outer(consX, X2, "-")/h)/h
B <- rep(1, length(consX)) %*% t(Y2 * DX)
if (type == 0) {
return(A * B)
}
if (type == 1) {
A2 <- .dderi(outer(consX, X2, "-")/h)/h^2
return(A2 * B)
}
if (type == 2) {
A3 <- .d2deri(outer(consX, X2, "-")/h)/h^3
return(A3 * B)
}
}
.dderi <- function (x)
{
return(-x * dnorm(x))
}
.d2deri <- function (x)
{
return((x^2 - 1) * dnorm(x))
}
library(asymmetric)
colors <- brewer.pal(7, "Set1")
x <- runif(75, min = 0, max = 1)
y <- 1/2*x^(1/2)*runif(75, min = 0, max = 2)
analysis_dat <- data.frame(x = x, y = y)
plot(x, y)
# QR, SFA, poly
qr_fake <- rq(y ~ x, tau = 0.95)
sfa_fake <- sfa(y ~ x | x, ineffDecrease = TRUE)
ols_fake <- lm(y ~ x)
bw <- kern_smooth_bw(x, y, method="u", technique="noh", bw_method="bic")
kernsmooth <- kernel_smoothing(x, y, y, h = bw)
par(mar=c(4,3,3,0), pty = "s")
plot(x, y, main = "Comparison of Each Technique on Simulated Asymmetric Data",
xlim = c(0,1), xlab = "", ylab = "", ylim = c(0,1), type = "p", pch = 19,
col="gray", xaxp = c(0, 1, 1), yaxp = c(0, 1, 1), cex.lab = 0.8,
cex.axis = 0.8, cex = 1.5)
abline(a = qr_fake$coefficients[1] , b = qr_fake$coefficients[2], col = colors[4],
lty = "dotted", lwd = 2)
abline(a = sfa_fake$mleParam[1], b = sfa_fake$mleParam[2], col = colors[5],
lty = "dotdash", lwd = 2)
points(x = sort(x), y = sort(kernsmooth), type = "l", lwd = 2,
col = colors[1], lty = "twodash")
abline(a = ols_fake$coefficients[1], b = ols_fake$coefficients[2], col = colors[7],
lty = 1, lwd = 2)
legend.txt <- c("Kernel", "QR (.95)", "SFA", "OLS")
legend('topleft', legend.txt,
lty=c("twodash", "dotted", "dotdash", "solid"),
col=c(colors[1], colors[4],colors[5], colors[7]),
bty='n', cex=.75, lwd = 2)
# AOC on simulated data (Table 2)
AOC_fd <- AH_AOC(dat = analysis_dat, input = analysis_dat$x,
output = analysis_dat$y, method = c("Kernel", "QR", "SFA"), print_style = "R",
CI = TRUE, nboots = 5000)
library(asymmetric)
library(RColorBrewer)
library(zoo)
library(pracma)
library(asymmetric)
library(RColorBrewer)
library(zoo)
library(pracma)
options(stringsAsFactors = FALSE)
colors <- brewer.pal(7, "Set1")
load("inst/extdata/Coxappend.RData")
# Make Figure 6 and Figure 7
CGG.test <- sfa(x$enps ~ x$eneth * x$lnml | x$eneth * x$lnml, ineffDecrease=TRUE)
yhat <- CGG.test$mleParam[1] + x$eneth*CGG.test$mleParam[2] +
x$lnml*CGG.test$mleParam[3] + x$eneth*x$lnml*CGG.test$mleParam[4]
xgrid <- seq(min(x$eneth), max(x$eneth), length=10)
wgrid <- seq(min(x$lnml), max(x$lnml), length=10)
frontier.pred <- function(x, w){
CGG.test$mleParam[1] + x*CGG.test$mleParam[2] + w*CGG.test$mleParam[3] +
x*w*CGG.test$mleParam[4]
}
ygrid <- outer(xgrid, wgrid, frontier.pred)
par(mfrow=c(1,2))
par(mar=c(2,2,2,2))
for(r in c(240,300)){
p <- persp(xgrid, wgrid, ygrid, col = "#FFFFFF22", border = "#00000022",
phi = 10, theta = r, xlab = "Electoral system permissiveness",
ylab = "Social heterogeneity", zlab = "Party system size", cex.lab = 0.7)
obs <- trans3d(x$eneth, x$lnml, x$enps, p)
pred <- trans3d(x$eneth, x$lnml, yhat, p)
points(obs, col = "black", pch = 19, cex = 0.2)
segments(obs$x, obs$y, pred$x, pred$y, col = "#00000022")
}
library(plot3D)
library(devtools)
document()
build()
install()
library(asymmetric)
library(RColorBrewer)
library(zoo)
library(pracma)
library(plot3D)
options(stringsAsFactors = FALSE)
colors <- brewer.pal(7, "Set1")
load("inst/extdata/Coxappend.RData")
# Make Figure 6 and Figure 7
CGG.test <- sfa(x$enps ~ x$eneth * x$lnml | x$eneth * x$lnml, ineffDecrease=TRUE)
yhat <- CGG.test$mleParam[1] + x$eneth*CGG.test$mleParam[2] +
x$lnml*CGG.test$mleParam[3] + x$eneth*x$lnml*CGG.test$mleParam[4]
xgrid <- seq(min(x$eneth), max(x$eneth), length=10)
wgrid <- seq(min(x$lnml), max(x$lnml), length=10)
frontier.pred <- function(x, w){
CGG.test$mleParam[1] + x*CGG.test$mleParam[2] + w*CGG.test$mleParam[3] +
x*w*CGG.test$mleParam[4]
}
ygrid <- outer(xgrid, wgrid, frontier.pred)
par(mfrow=c(1,2))
par(mar=c(2,2,2,2))
for(r in c(240,300)){
p <- persp(xgrid, wgrid, ygrid, col = "#FFFFFF22", border = "#00000022",
phi = 10, theta = r, xlab = "Electoral system permissiveness",
ylab = "Social heterogeneity", zlab = "Party system size", cex.lab = 0.7)
obs <- trans3d(x$eneth, x$lnml, x$enps, p)
pred <- trans3d(x$eneth, x$lnml, yhat, p)
points(obs, col = "black", pch = 19, cex = 0.2)
segments(obs$x, obs$y, pred$x, pred$y, col = "#00000022")
}
CGG.test.reduced <- sfa(x$enps ~ x$eneth * x$lnml, ineffDecrease=TRUE)
lrtest <- -2*CGG.test.reduced$mleLogl + 2*CGG.test$mleLogl
pchisq(lrtest, df=4, lower.tail=FALSE)
resid <- x$enps - yhat
simpleCap <- function(x) {
s <- strsplit(x, " ")[[1]]
paste(toupper(substring(s, 1,1)), substring(s, 2),
sep="", collapse=" ")
}
x$var12[45] <- "St. Kitts and Nevis"
x$var12[46] <- "St. Lucia"
x$var12[47] <- "St. Vincent & Grenadines"
x$var12[51] <- "United Kingdom"
x$var12[52] <- "United States"
##############
# Figure 7
##############
dotchart(sort(resid), labels=sapply(tolower(x$var12[order(resid)]), simpleCap),
cex=0.4, pch=19, lcolor="gray90", main="Party System Size 'Inefficiency'")
abline(v=0)
#############
# Do AOC Test
#############
CGG.test <- sfa(x$enps ~ x$eneth * x$lnml | x$eneth * x$lnml, ineffDecrease=TRUE)
yhat <- CGG.test$mleParam[1] + x$eneth*CGG.test$mleParam[2] +
x$lnml*CGG.test$mleParam[3] + x$eneth*x$lnml*CGG.test$mleParam[4]
cgg_function <- function(x, y)
{
CGG.test$mleParam[1] + x * CGG.test$mleParam[2] + y * CGG.test$mleParam[3] +
x * y * CGG.test$mleParam[4]
}
plane_function <- function(x, y)
{
CGG.test$mleParam[1]
}
AOC_SFA_3D <- function(x, y, fun)
{
integral <- integral2(fun = cgg_function, xmin = min(x), xmax = max(x),
ymin = min(y), ymax = max(y))
AUC_lower <- integral2(fun = plane_function, xmin = min(x),
xmax = max(x), ymin = min(y), ymax = max(y))
AUC_dif <- integral$Q - AUC_lower$Q
AUC <- (AUC_dif)/((max(x) - min(x)) * (max(y) -
min(y)) * (max(cgg_function(x, y)) - min(cgg_function(x, y))))
1 - AUC
}
#################
# AOC for Table 6
#################
AOC_SFA_3D(x = x$eneth, y = x$lnml, fun = cgg_function)
boot_CGG <- function(dat)
{
idx <- sample(1:nrow(dat), nrow(dat), replace=TRUE)
sample.dta <- dat[idx,]
x <- sample.dta$eneth
y <- sample.dta$lnml
CGG.test <- sfa(sample.dta$enps ~ x * y | x * y, ineffDecrease=TRUE)
cgg_function <- function(x, y)
{
CGG.test$mleParam[1] + x * CGG.test$mleParam[2] + y * CGG.test$mleParam[3] +
x * y * CGG.test$mleParam[4]
}
plane_function <- function(x, y)
{
CGG.test$mleParam[1]
}
integral <- integral2(fun = cgg_function, xmin = min(x), xmax = max(x),
ymin = min(y), ymax = max(y))
AUC_lower <- integral2(fun = plane_function, xmin = min(x),
xmax = max(x), ymin = min(y), ymax = max(y))
AUC_dif <- integral$Q - AUC_lower$Q
AUC <- (AUC_dif)/((max(x) - min(x)) * (max(y) -
min(y)) * (max(cgg_function(x, y)) - min(cgg_function(x, y))))
1 - AUC
}
dat <- x
rm(x)
nboots <- 5
boots <- c()
for(i in 1:nboots){
idx <- sample(1:nrow(dat), nrow(dat), replace=TRUE)
sample.dta <- dat[idx,]
x <- sample.dta$eneth
y <- sample.dta$lnml
CGG.test <- sfa(sample.dta$enps ~ x * y | x * y, ineffDecrease=TRUE)
cgg_function <- function(x, y)
{
CGG.test$mleParam[1] + x * CGG.test$mleParam[2] + y * CGG.test$mleParam[3] +
x * y * CGG.test$mleParam[4]
}
plane_function <- function(x, y)
{
CGG.test$mleParam[1]
}
integral <- integral2(fun = cgg_function, xmin = min(x), xmax = max(x),
ymin = min(y), ymax = max(y))
AUC_lower <- integral2(fun = plane_function, xmin = min(x),
xmax = max(x), ymin = min(y), ymax = max(y))
AUC_dif <- integral$Q - AUC_lower$Q
AUC <- (AUC_dif)/((max(x) - min(x)) * (max(y) -
min(y)) * (max(cgg_function(x, y)) - min(cgg_function(x, y))))
boots[i] <- 1 - AUC
}
#################
# CIs for Table 6
#################
quantile(boots, c(0.025, 0.5, 0.975))
library(asymmetric)
# Do QR on HW
dat_gdp <- load_dataset("gdp_ppp")
dat_life <- load_dataset("life_expect")
# log GDP
dat_gdp[, 2:217] <- log(dat_gdp[, 2:217])
columnsgdp <- c("state", paste("gdp",seq(from = 1800, to = 2015), sep = "_"))
columnslife <- c("state", paste("life",seq(from = 1800, to = 2015), sep = "_"))
colnames(dat_gdp) <- columnsgdp
colnames(dat_life) <- columnslife
dat_life <- dat_life[,-1]
dat <- data.frame(cbind(dat_gdp, dat_life))
dat <- dat[complete.cases(dat),]
gdps <- dat[2:217]
dat <- melt(dat)
dat$variable <- as.character(dat$variable)
variable <- do.call(rbind, strsplit(dat$variable, split =  "_"))[,1]
date <- do.call(rbind, strsplit(dat$variable, split =  "_"))[,2]
dat$variable <- variable
dat$date <- as.numeric(date)
dat <- dcast(dat, state + date ~ variable)
setDT(dat)
setnames(dat, c("state", "year", "gdp", "life"))
qr_funct <- function(date, DT) {
sub_dat <- DT[year == date]
qr <- rq(life ~ gdp, tau = 0.95, data = sub_dat)
qr$fitted
}
get_gdps <- function(date)
{
sub_dat <- dat[year == date]
sub_dat$gdp
}
dates <- seq(from = 1810, to = 2015, by = 20)
yrs20 <- seq(1, 215, by = 20)
gdps <- as.data.table(sapply(dates, get_gdps))
results <- as.data.table(sapply(dates, qr_funct, DT = dat))
setnames(gdps, as.character(yrs20))
setnames(results, as.character(yrs20))
gdps[["1810"]]
points(gdps[["1810"]], results[["1810"]])
# Get Bootstraps for every 20 years
qr_20_years_bootstrap <- function(dat, date, nboots)
{
boots <- function(dat, date){
dta <- dat[year == date]
idx <- sample(1:nrow(dta), nrow(dta), replace=TRUE)
sample.dta <- dta[idx,]
qr <- rq(life ~ gdp, tau = 0.95, data = sample.dta)
qr$coefficients[1] + dta[, gdp] * qr$coefficients[2]
}
reps <- apply(replicate(nboots, boots(dat, date)), 2, sort)
quantiles <- apply(reps, 1, quantile, probs = c(0.025, 0.975))
quantiles
}
dates <- seq(from = 1810, to = 2010, by = 20)
bootstraps <- lapply(dates, qr_20_years_bootstrap, dat = dat, nboots = 5000)
names(bootstraps) <- seq(1, 215, by = 20)
# Make Figure 5
yrs20 <- seq(1, 215, by = 20)
par(mar=c(2,2,0,0))
par(mfrow=c(2,6), oma = c(0, 0, 2, 0))
for(i in seq(from = 1, to = 215, by = 20)){
plot(0, xlim=c(5,12), ylim=c(15,90), type = "n", xlab = " ", ylab = " ",
main = " ", axes=FALSE)
axis(2, labels=FALSE, col="#88888888")
if(i==1 | i==121){axis(2, labels=TRUE, col="#88888888", col.axis="#88888888")}
if(i>120){axis(1, labels=c("150","1,500","15,000","150,000"),
at=c(5.01,7.31,9.61,11.91), col="#88888888", col.axis="#88888888")}
points(dat[year == 1799 + i, gdp], dat[year == 1799 + i, life], pch=".",
col="#88888888", cex = 2)
points(eval(parse(text = paste0("gdps[['", i, "']]"))),
eval(parse(text = paste0("results[['", i, "']]"))), type = "l",
col = "black", lwd = 1)
ylow <- eval(parse(text = paste0("bootstraps$`", i, "`")))[1,]
yhigh <- eval(parse(text = paste0("bootstraps$`", i, "`")))[2,]
polygon(x = c(sort(eval(parse(text = paste0("gdps[['", i, "']]")))),
rev(sort(eval(parse(text = paste0("gdps[['", i, "']]")))))), c(sort(ylow),
rev(sort(yhigh))), col = alpha("grey30", 0.25), border = NA)
text(6,75, as.character(1809 + i))
}
mtext("Life Expectancy vs. GDP Across Generations", outer = TRUE, cex = 1.5)
